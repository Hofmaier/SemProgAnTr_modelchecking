\documentclass[11pt,twoside,a4paper]{article}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{tikz}
\usetikzlibrary{automata,positioning}
\usepackage{glossaries}
\usepackage{amsmath,amssymb}
\usepackage{todonotes}

\begin{document}

\title{Model Checking with Spin}
\author{Lukas Hofmaier}
\date{today}
\maketitle

\tableofcontents

\section{Model Checking}
\label{sec:modelchecking}

The Goal of a model checker is to verify behavioral models. That is, a model checker verifies whether a condition for a given model holds. Spin is a model checker. The model is described in Promela. Promela is a system specification language. The condition or property is described by linear temporal logic. In the next section model checking is compared to other verification methods. The section describes the advantages of model checking. The next next section explains how to use Promela to describe the behavior of a model. The next section describes correctness properties in general and how to define properties with temporal linear logic(LTL). Spin takes Promela source code and the LTL Properties as input and tells the user if the model holds for the defined properties.

\subsection{Why Model Checking}
\label{sec:why}

Among others, there are two options to verify software
\begin{description}
\item[Peer reviewing] Code is analyzed statically. Since the code is not compiled and executed, it is difficult to detect errors, caused by concurrency.
\item[Software testing] Software is compiled and executed. The system reads explicitly defined input and a subset of all possible paths is executed. The Output is compared with the specification. Practically, it is impossible to cover all possible paths through testing. Testing can expose errors. It doesn't proofs the absence of errors.
\end{description}

Peer reviewing and testing are both unable to verify 100\% of all possible cases. In a model-based verification a behavioral model is written and correctness properties are defined. A model checker processes the model and the properties and checks if the properties hold for the defined model. If the properties don't hold the model checker presents the user a counterexample. A counterexsample is a sequence of states which resulted in a undesirable state \cite{baier08}.

\section{Modeling Concurrent Systems}
\label{sec:concurrency}

Dieser Abschnitt zeigt wie Modelle mit Promela beschrieben werden und wie sich Concurrency auf das Statediagram eines Programms auswirkt. Jedes Programm kann als Statediagramm modelliert werden. Meistens werden jedoch nicht die relevanten Teile modelliert und nicht jeder State des Programm Counters.

\subsection{Promela}
\label{sec:promela}

Spin verifiziert Modelle, die in der Sprache Promela beschrieben sind. Sp"ater werden Konzepte anhand von Promela-Codebeispielen beschrieben. Dieser Abschnitt soll zum Verst"andnis der Codebeispiele beitragen.

Promela dient Abstraktionen von Systemen (abstractions of systems designs) zu beschreiben. Es ist eine specification language. Das Promela-Model beschreibt das Verhalten eines Systems. Promela erm"oglicht es die Synchronisation von concurrent systems zu modellieren.

Die Syntax zur Deklaration der Variablen ist "ahnlich wie in der Programmiersprache C. In den nachfolgenden Beispielen wird nur der Datentyp byte verwendet.

Mit dem keyword \verb|proctype| wird ein process type definiert. Auf \verb|proctype| folgen der Bezeichner und in Klammer \verb|{}| die statements des process type. \cite{holzmann03}

Das keyword \verb|active| veranlasst Spin eine Instanz des folgenden process type zu erstellen. Der Prozess startet sofort. 

\subsection{Interleaving}
\label{sec:interleaving}

Listing \ref{lst:interleavingcode} zeigt ein System in dem genau ein Prozess gestarted wird. Die statements in Prozess \verb|sequential| werden sequenziel ausgef"uhrt. Es wird eine Prozessinstanz vom type process \verb|sequential| erzeugt. Diese liest den Wert der globalen Variablen \verb|x|, addiert $2$ dazu und speichert das Resultat in der Variablen \verb|temp|. Danach wird der Wert in \verb|temp| \verb|x| zugewiesen. Die Reihenfolge der States, die das System einnehmen kann ist eindeutig. Das Statediagram dazu wird in Abbildung \ref{fig:sequencielstatediagram} gezeigt. Die Reihenfolge der statements ist eindeutig.


 \lstinputlisting[float,label={lst:interleavingcode},caption={System with a single process},numbers={left},float,language=Promela]{sequential.pml}  
  \label{fig:interleavinglisting}


\begin{figure}
  \centering
  \begin{tikzpicture}[node distance=2cm, on grid, auto]
    \node[state, initial, rectangle, align=left](s1){$x=0$\\ $tempA=0$};
    \node[state, rectangle, align=left, below =of s1](s2){$x=0$\\$tempA=2$};
    \node[state, rectangle, align=left, below =of s2](s3){$x=2$\\$tempA=2$};
    \path[->](s1) edge node {0}(s2);
    \path[->](s2) edge node {$x=temp$}(s3);
  \end{tikzpicture}
  \caption{Statediagram zu sequenziellem Programm}
  \label{fig:sequencielstatediagram}
\end{figure}

Werden Programme concurrent ausgef"uhrt, gibt es mehrere M"oglichkeiten, in welcher Reihenfolge die Statements ausgef"uhrt werden. Es unterschiedliche Abfolgen von states m"oglich. Bei jedem "Ubergang wird nondeterministic entschieden, welcher Process als n"achstes ausgef"uhrt wird. Das zusammenf"uhren der Statements beider Process zu einer sequenziellen Abfolge nennt man Interleaving. Interleaving ist die Enumeration aller m"oglichen statement Reihenfolgen. Listing \ref{list:interleaving2proc} zeigt ein Program bei dem 2 Processe $A$ und $B$ concurrent ausgef"uhrt werden. Das Statediagram wird Abbildung \ref{fig:interleavingtransitionsystem} gezeigt.

\lstinputlisting[label=list:interleaving2proc, caption={Add operation with 2 processes},numbers=left,float,language=Promela]{interleavingproc.pml}  

\begin{figure}
 \begin{tikzpicture}[node distance=2.5cm, on grid, auto]
\tikzstyle{every node}=[font=\tiny]
   \node[state, initial, rectangle, align=left](s1){$x=0$\\$tempA=0$\\$tempB=0$};
   \node[state, rectangle, align=left](s2) [below left=of s1]{$x=0$\\$tempA=2$\\$tempB=0$};
   \node[state, rectangle, align=left](s3)[below left=of s2]{$x=2$\\$tempA=2$\\$tempB=0$};
  \node[state, rectangle, align=left](s4)[below left=of s3]{$x=2$\\$tempA=2$\\$tempB=7$};
\node[state, rectangle, align=left](s5)[below =of s4]{$x=7$\\$tempA=2$\\$tempB=7$};
\node[state, rectangle, align=left](s6)[below right=of s1]{$x=0$\\$tempA=0$\\$tempB=5$};
\node[state, rectangle, align=left](s7)[below right=of s6]{$x=5$\\$tempA=0$\\$tempB=5$};
\node[state, rectangle, align=left](s8)[below right=of s7]{$x=5$\\$tempA=7$\\$tempB=5$};
\node[state, rectangle, align=left](s9)[below =of s8]{$x=7$\\$tempA=7$\\$tempB=5$};
\node[state, rectangle, align=left](s10)[below right=of s2]{$x=0$\\$tempA=2$\\$tempB=5$};
\node[state, rectangle, align=left](s11)[below left=of s10]{$x=2$\\$tempA=2$\\$tempB=5$};
\node[state, rectangle, align=left](s12)[below right=of s10]{$x=5$\\$tempA=2$\\$tempB=5$};
   \path[->](s1) edge node {$tempA=x+2$}(s2);
   \path[->](s2) edge node {$x=tempA$}(s3);
   \path[->](s3) edge node {$tempB=x+5$}(s4);
\path[->](s4) edge node {$x=tempB$}(s5);
\path[->](s1) edge node {$tempB=x+5$}(s6);
\path[->](s6) edge node {$x=tempB$}(s7);
\path[->](s7) edge node {$tempA=x+2$}(s8);
\path[->](s8) edge node {$x=tempA$}(s9);
\path[->](s2) edge node {$tempB=x+5$}(s10);
\path[->](s6) edge node {$tempB=x+5$}(s10);
\path[->](s10) edge node {$x=tempA$}(s11);
\path[->](s10) edge node {$x=tempB$}(s12);

 \end{tikzpicture}   

 \caption{State diagram for system in Listing \ref{list:interleaving2proc}}
\label{fig:interleavingtransitionsystem}
 \end{figure}

Das Statediagram in Abbildung \ref{fig:interleavingtransitionsystem} zeigt, dass das Program in 4 unterschiedliche States terminieren kann. Der resultierende State der Computation ist non-deterministic. M"ochte man sicherstellen, dass bestimmte States nie eintreten, kann mit Spin der Statespace nach unerw"unschten States durchsucht werden.

\subsection{Synchronization}
\label{sec:synchronization}

Listing \ref{lst:withoutsemaphore} zeigt ein Programm, in dem zwei Prozesse concurrent gestartet werden und zum Wert der Variablen $x$ den Wert $2$ dazuz"ahlen. Wenn man erzwingen m"ochte, dass das Programm mit dem Wert $4$ in $x$ terminiert, muss man die Prozesse synchronisieren. Die Prozesse m"ussen so synchronisiert werden, dass jeweils nur ein Prozess in der critical section (line 4-6) ist. Eine M"oglichkeit um mutal exclusion zu erreichen ist der Einsatz von Semaphoren. Listing \ref{lst:withsemaphore} zeigt ein Programm wie mutual exlusion mit einer Semaphore erreicht wird. Wenn dieses Programm terminiert, hat die Variable $x$ immer den Wert $4$.

\lstinputlisting[label={lst:withoutsemaphore},caption={Program without mutual exlusion}, numbers=left,float,language=Promela]{withoutsemaphore.pml}

Der Test \verb|x<0| und die nachfolgende \verb|x--| Operation m"ussen atomar ausgef"uhrt werden, damit die \verb|request_semaphore| Operation der Semaphore funktionert. In Promela werden sequenzen von statements atomar ausgef"uhrt, in dem man die statements innerhalb geschweifter Klammer mit vorangestelltem \verb|atomic| schreibt.

Boolsche expressions, wie \verb|x<0|, ohne assigment, blockieren Prozesse wenn die expression zu False evaluiert bis sie zu true evaluiert wird.

\lstinputlisting[label={lst:withsemaphore},numbers=left,float,language=Promela,caption={Mutual exlusion with semaphores}]{semaphore.pml}

Werden in einem Programm mehrere Locks verwendet, kann es zu einem Deadlock kommen. Listing \ref{list:deadlock} zeigt ein Programm, bei dem es zu einem Deadlock kommen kann. Wenn Process \verbTakeAFirst die Semaphore $A$ decrementiert und gleich danach unterbrochen wird und Process \verbTakeBFirst unmittelbar danach Semaphore $B$ dekrementiert, kann keiner der beiden Processe weiterfahren, weil die ben"otigte Resource gelockt ist.

In Abschnitt \ref{sec:ltl} wird beschrieben, wie Spin Deadlocks in Modellen findet.

\lstinputlisting[label=list:deadlock,numbers=left,float,language=Promela,caption={Synchronization with deadlock}]{deadlock.pml}

\section{Correctness Properties}
\label{sec:ltl}

 Der Sachverhalt kann mit Linear Temporal Logic beschrieben werden. Dieser Abschnitt erkl"art LTL. Ein Sachverhalt ist zum Beispiel, ob ein Model keine Deadlocks enth"alt. Die Eigenschaft, dass ein Model keinen Deadlock enth"alt, kann mit LTL formalisiert werden. Zuerst werden atomic propositions beschrieben, da sie ein Bestandteil einer LTL-Formel sind. LTL-Formel spezifizieren Linear-Time Properties. Sogenannte Traces von Systemen k"onnen mit Linear-Time Properties "uberpr"uft werden. Deshalb wird auch erkl"art was Traces und Linear Time Properties sind.

\subsection{Atomic Propositions}
\label{sec:atomicpropositions}

Atomic propositions sind Aussagen, die wahr oder falsch sein k"onnen. Eine boolean expression ist eine atomic proposition. Sie werden zu \verb|True| oder \verb|False| evaluiert. Die Evaluation ist vom state in dem sich das System zu einem Zeitpunkt befindet abh"angig. Der Ausdruck \verb|crit < 2| ist eine atomic proposition. Atomic propositions k"onnen durch Bezeichner ersetzt werden. Beispielweise k"onnte man die Aussage "Process \verb|TakeAFirst| hat \verb|mutexA| erhalten und wartet darauf, dass \verb|mutexB| frei wird" "uber das 
System aus Listing \ref{list:deadlock} mit $waitA$ bezeichnen. Dieses Beispiel wird in Abschnitt wiederverwendet um Deadlockfreiheit zu beschreiben.

Die Menge $AP$ definiert die Menge aller atomic propositions eines Systems. Jedem State kann man eine Menge g"ultiger atomic propositions zuordnen. Die Teilmenge ist enthalten in $2^{AP}$.
 
Atomic propositions k"onnen mit den Operatoren der Aussagenlogik (siehe Tabelle \ref{tab:operators_of_propositionallogic}) verkn"upft werden.


\begin{table}
  \centering

  \begin{tabular}{l l l}
    Operator & Math & Spin \\
    not & $\neg$ & \verb|!| \\
    and & $\land$ & \verb|&&| \\
  \end{tabular}
  \caption{Operators of propositional logic }
  \label{tab:operators_of_propositionallogic}
\end{table}

\subsection{Traces}
\label{sec:traces}

Die Verhaltensmodelle aus Abschnitt \ref{sec:interleaving} koennen in einer Simulation ausgefuehrt werden. Die Ausfuehrung ist eine unter vielen moeglichen Abfolgen von States. Eine moegliche Abfolge startet in einem initial state und endet in einem terminal state. Jedem state kann ein Set von atomic propositions zugeordnet werden, die g"ultig sind. Ein Trace ist eine sequence von Sets, die g"ultige atomic propositions beinhalten. Ein Trace ist also ein Wort "uber dem Alphabet $2^{AP}$.

Da es in einem System $S$ mehrere Ausfuehungspfade geben kann, kann es auch mehrere Traces geben. Alle Traces eines System $S$ bezeichnet man $Traces(S)$. $Traces(S)$ definiert eine Sprache.

Anhand von Listing \ref{lst:criticalsection} wird nachfolgend eine m"ogliche sequence von states und ein Trace gezeigt.

\lstinputlisting[label=lst:criticalsection,caption={Critical section problem},numbers=left]{criticalsection.pml}

Ein state kann als Triple, bestehend aus dem Wert der variable \verb|crit| und location counters der Prozesse \verb|A| und \verb|B| repr"asentiert werden. Der erste Wert im Triple zeigt, bei welcher line number sicher location counter von Prozess \verb|A| befindet und der zweite von Prozess \verb|B|.
Eine m"ogliche sequence $\pi$ von states die bei der Simulation des Systems in Listing \ref{lst:criticalsection} ist

\begin{equation}
  \label{eq:path}
  \begin{split}
\pi = (4, 9, {critA}={False},{critB}=False) \rightarrow \\
(6, 9, {critA}={True},{critB}=False) \rightarrow \\
(7, 9, {critA}={False},{critB}=False) \rightarrow \\
(7, 11, {critA}={False},{critB}=True) \rightarrow \\
(7, 12, {critA}={False},{critB}=False)
  \end{split}
\end{equation}

In diesem Beispiel k"onnen die beiden Bool-Variablen \verb|critA| und \verb|critB| als atomic proposition verwendet werden. Die Menge der atomic propositions $AP$ in diesem Beispiel ist
\[
\text{AP}=\{critA, critB\}
\]

Der Trace zu einem zur sequence \ref{eq:path} ist das Wort
\[
trace(\pi) = \varnothing \{critA\} \varnothing \{critB\} \varnothing
\]

\subsection{Linear-Time Properties}
\label{sec:satisfactionrelations}

Linear-time Properties legen fest welche W"orter von einem System akzeptiert werden d"urfen. Ein Linear-time property ist eine Sprache "uber dem Alphabet $2^{AP}$.
Wenn $P$ ein LT Property und $S$ das modellierte System ist, dann erf"ullt $S$ $P$ (man schreibt $S \models P$) wenn Traces(S) $ Traces(S) \subseteq P $

\[
TS \models P \iff Traces(S) \subseteq P 
\]

$ \models $ ist eine satisfaction relation. 

Linear-time Properties k"onnen in Safety-, Liveness- und Fairness-Properties unterteilt werden. In den Abschnitten \ref{sec:safety} und \ref{sec:liveness} werden Safety- und Liveness-Properties erkl"art.

\subsubsection{Safety-properties}
\label{sec:safety}

Ein Safety-Property verifiziert, ob ein System unerw"unschte states enth"alt. 

Deadlock ist ein safety property. Deadlockfreiheit im System aus Listing \ref{list:deadlock} kann wie folgt als safety property definiert werden. Die atomic propositions $waitA$ und $waitB$ bezeichnen die Zust"ande, dass die processes \verb|TakeBFirst| und \verb|TakeAFirst| jeweils auf die anderen Mutex warten. Dann muss die Aussagenlogikformel  $\phi=\neg waitA \lor \neg waitB$ in jedem state True sein. Formell:

\[
P_{dlock} = {A_0 A_1 A_2 \dots \in (2^{AP})^{\omega} | \forall \geq i.   A_i \models \phi}
\]

wobei $(2^{AP})^{\omega}$ die Menge aller m"oglichen W"orter "uber $2^{AP}$ ist.

Auch Mutual exlusion kann mit einem Safety-Property verifiziert werden. Ein Safety-Property $P_{mutex}$ um mutual exlusion im System aus Listing \ref{lst:criticalsection} sicherzustellen, definiert eine Sprache in der keine W"orter mit $\{critA,critB\}$ vorkommen d"urfen. Formell:
\[
P_{mutex} = \text{Menge aller W"orter} A_0 A_1 A_2 \dots \text{mit } \{critA,critB\} \not \subseteq A_i \text{ f"ur alle } 0 \leq i
\]
\[
 = {A_0 A_1 A_2 \dots \in (2^{AP})^{\omega} | \forall \geq i.   A_i \models \neg critA \lor \neg critB}
\]

Ein Modelchecker "uberpr"uft, ob Traces(S) eines Systems $S$ ein Wort (trace) enth"alt, dass die Anforderung des definierten Property nicht erf"ullt.

\subsubsection{Liveness-Properties}
\label{sec:liveness}

Safety-Properties definieren, dass in einer Sprache bestimmte Prefixe nicht vorkommen. Ein System $S$ das nichts tun w"urde, dass heisst $Traces(S)=\varnothing$ w"urde jedes Safety-Property erf"ullen. Fortschritt muss auch verfiziert werden k"onnen. Liveness-Properties definieren, dass jeder Trace in einem System erweitert werden kann, sodass das resultierende Wort das Liveness-Property erf"ullt.

Ein Liveness-Property fordert, dass sich gewisse events unendlich oft wiederholen. Liveness-Properties k"onnen nur von einem infiniten Trace erf"ullt werden. 

Starvation freedom ist ein Liveness Property. Starvation freedom fordert, dass jeder wartende Process eventuell seine critical section betritt. In einem infiniten Trace gibt es kein Prefix, dass starvation freedom verletzt. Aufgrund eines Prefix in einem infinten Trace kann man nicht "uberpr"ufen, ob ein Sachverhalt in Zukunft eintreten wird.

Formell kann man starvation freedom folgendermassen ausdr"ucken.
\[
P_{Starv} = \text{Menge aller infiniten W"orter } A_0 A_1 \dots A_j \in AP \text{ so dass }\exists j \geq 0. critA \in A_j
\]
\[
 = { A_0 A_1 \dots A_j \in (2^{AP})^{\omega} \exists j \geq 0. critA \in A_j}
\]

Listing \ref{lst:starvation} zeigt ein System $S_{Spinlock}$ bei dem starvation freedom nicht erf"ullt ist. Process A versucht den \verb|mutexB| mit einem Spinlock zu erlangen. In diesem System gibt es Traces, bei denen Process A in einem unendliche Loop versucht \verb|mutexB| zu erlangen und so nie in die eigene critical section kommt. Ein solcher Trace erf"ullt das LTL-Property \verb|<>critA| nicht. $S_{Spinlock}$ erf"ullt $P_{Starv}$ nicht.

\lstinputlisting[label={lst:starvation},caption={Critical section with starvation},numbers=left, language=Promela,float]{starvation.pml}

\subsection{Linear Temporal Logic}
\label{sec:lineartemporallogic}

M"ochte man ein Model, dass in Promela definiert ist, von Spin verifizieren lassen, muss man Spin das Model als Promela Source Code und die Definition eines Correctness-Property geben. Die Safety und Liveness-Properties aus Abschnitt \ref{sec:safety} und \ref{sec:liveness} sind ungeeignet f"ur die Eingabe. Linear Temporal Logic ist ein Formalismus mit dem Correctness Properties einfacher formuliert werden k"onnen.

Ein LTL-Formel besteht aus atomic propositions, die mit Operatoren der Aussagenlogik  und der temporal logic verkn"upft werden.

Mit atomic propositions kann man nur "uberpr"ufen, ob ein property in einem gegebenen state $s$ wahr oder falsch ist. M"ochte man beispielsweise mutual exlusion in Program \ref{lst:withoutsemaphore} ausdr"ucken, ben"otigt man Operatoren, die sich auf alle m"oglichen states beziehen. Temporal operators erm"oglichen solche Aussagen (siehe Tabelle \ref{tab:temporal_operators}). Die Formel k"onnen mit ASCI-Character ausgedr"uckt werden. Diese Form eignet sich f"ur die Eingabe von Spin.

\begin{table}
  \centering
  \begin{tabular}{l l l}
    Operator & Math & Spin \\
    always & $\square$ & \verb|[]| \\
    and & $\lozenge$ & \verb|<>| \\
  \end{tabular}
  \caption{Temporal operators }
  \label{tab:temporal_operators}
\end{table}

Das Mutual Exlusion Safetyproperty $P_{mutex}$ aus Abschnitt \ref{sec:safety} kann in LTL pr"agnanter definiert werden
\[
  {A_0 A_1 A_2 \dots \in (2^{AP})^{\omega} | \forall \geq i.   A_i \models \neg critA \lor \neg critB}
\]

\[
= \square \neg (critA,critB)
\]

Das Livenessproperty $P_{Starv}$ f"ur Starvation freedom wird in LTL wie folgt definiert:
\[
 { A_0 A_1 \dots A_j \in (2^{AP})^{\omega} \exists j \geq 0. critA \in A_j}
\]

\[
= \lozenge critA
\]

\appendix

\begin{thebibliography}{9}
\bibitem{baier08}
Christel Baier Joost-Pieter Katoen,
Principles of Model Checking,
The MIT Press,
2008.

\bibitem{holzmann03}
Gerald Holzmann,
The Spin Model Checker: Primer and Reference Manual,
Addison-Wesley Professional,
2003.
\end{thebibliography}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "master"
%%% End: 
